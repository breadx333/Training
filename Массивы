1. Заполнить массив нулями, кроме первого и последнего элементов, которые должны быть равны единице.
        a = int(input())

        q = []

        for i in range(0, a):
            if i==0:
                q.append(-1)
            elif i==a-1:
                q.append(1)
            else:
                q.append(0)

        print(numpy.array(q))

2. Заполнить массив нулями и единицами, при этом данные значения чередуются, начиная с нуля.
        a = int(input(""))

        q = []

        for i in range(0, a):
                if i%2==0:
                    q.append(0)
                else:
                    q.append(1)
        
        print(numpy.array(q))

3. Заполнить массив последовательными нечетными числами, начиная с единицы.
        a = int(input(""))

        q = []

        for i in range(0, a):
                if i%2==0:
                    pass
                else:
                    q.append(i)

        print(numpy.array(q))

4. Сформировать массив из элементов арифметической прогрессии с заданным первым элементом x и разностью d.
        import numpy

        a = int(input("Начиная от: "))
        b = int(input("До: "))
        d = int(input("Разность числел: "))

        q = []

        if a>b:
            b = b-2
            d = -d
        for i in range(a, b+1, d):
            q.append(i)

        print(numpy.array(q))
        
5. Сформировать возрастающий массив из четных чисел.
        import numpy

        a = int(input("Начиная от: "))
        b = int(input("До: "))

        q = []

        for i in range(a, b+1):
            if i%2==0:
                q.append(i)

        print(numpy.array(q))
        
6. Сформировать убывающий массив из чисел, которые делятся на 3.
        import numpy

        a = int(input("Начиная от: "))
        b = int(input("До: "))

        q = []

        for i in reversed(range(a, b+1)):
            if i%3==0:
                q.append(i)

        print("Данные идут по убыванию", numpy.array(q))
        
7. Создать массив из n первых чисел Фибоначчи.
        import numpy

        a = int(input("Длина Фибоначчи: "))

        q = [0, 1]

        fib1 = q[-2]
        fib2 = q[-1]

        for i in range(a-2):
            summa = fib1 + fib2
            fib1 = fib2
            fib2 = summa
            q.append(summa)

        print(numpy.array(q))

8. Заполнить массив заданной длины различными простыми числами. Натуральное число, большее единицы, называется простым, если оно делится только на себя и на единицу.
        import numpy
        import random

        a = int(input("Длина Фибоначчи: "))

        q = []
        d = []

        for i in range(1, 1000):
            f = []
            for j in range(1, 1000):
                if i%j==0:
                    f.append(i)
            if len(f)==2:
                d.append(i)

        for k in range(0, a):
            q.append(random.choice(d))

        print(numpy.array(q))
        
9. Создать массив, каждый элемент которого равен квадрату своего номера.
        import numpy
        import random

        a = int(input("Длина Фибоначчи: "))

        q = []

        for i in range(0, a):
            q.append(i*i)

        print(numpy.array(q))
        
10. Создать массив, на четных местах в котором стоят единицы, а на нечетных местах - числа, равные остатку от деления своего номера на 5.
        import numpy ##Хз, наверное будет так
        import random

        a = int(input("Длина Фибоначчи: "))

        q = []

        for i in range(0, a):
            if i%2==0:
                q.append(1)
            else:
                l = i%5
                q.append(l)

        print(q)
        
11. Создать массив, состоящий из троек подряд идущих одинаковых элементов.
        import numpy
        import random

        a = int(input("Длина Фибоначчи: "))

        q = []

        for i in range(0, a):
            l = random.randint(1, 999)
            for j in range(0, 3):
                q.append(l)

        print(numpy.array(q))

12. Создать массив, который одинаково читается как слева направо, так и справа налево.
        import numpy
        import random

        a = int(input("Длина Фибоначчи: "))

        q = []

        for i in range(0, a):
            l = random.randint(1, 999)
            q.append(l)

        w = q + q[::-1]

        print(numpy.array(w))
        
13. Сформировать массив из случайных чисел, в которых ровно две единицы, стоящие на случайных позициях.
        import numpy
        import random

        a = int(input("Длина Фибоначчи: "))

        q = []

        for i in range(0, a):
            l = random.randint(1, 999)
            q.append(l)

        if len(q)==1:
            q = [1]
        else:
            while q.count(1)<2:
                q[random.randint(0, len(q)-1)] = 1

        print(numpy.array(q))
        
14. Заполните массив случайным образом нулями и единицами так, чтобы количество единиц было больше количества нулей.
        import numpy
        import random

        q = []

        for i in range(0, random.randint(1, 100)):
            l = 0
            q.append(l)

        while q.count(1)<=q.count(0):
            q[random.randint(0, len(q)-1)] = 1

        print(numpy.array(q), q.count(1), q.count(0))

15. Сформировать массив из случайных целых чисел от 0 до 9 , в котором единиц от 3 до 5 и двоек больше троек.
        import numpy ##Я знаю что этот код можно написать более оптимизировано, но пока так, еще у меня как всегда сезонно начал забиватся нос
        import random

        q = []
        d = random.randint(3, 5)

        for i in range(0, random.randint(1, 100)):
            l = random.randint(0, 9)
            q.append(l)

        while 3>q.count(1):
            q[random.randint(0, len(q)-1)] = 1

        while 5<q.count(1):
            if q[random.randint(0, len(q)-1)] == 1:
                q[random.randint(0, len(q)-1)] = random.randint(0, 9)
            else:
                pass

        while q.count(2)<=q.count(3):
            l = random.randint(0, len(q)-1)
            if q[l]!=1:
                q[l] = 2
            else:
                pass

        print(numpy.array(q), q.count(1), q.count(2), q.count(3))
        
16. Создайте массив, в котором количество отрицательных чисел равно количеству положительных и положительные числа расположены на случайных местах в массиве.
        import numpy ##Код рабочий, но с каким то багом, он иногда не работает, не разобрался почему
        import random

        q = []
        pol = 0
        otr = 0

        for i in range(0, random.randint(2, 100)):
            l = random.randint(0, 9)
            q.append(l)
            pol+=1

        while otr!=pol:
            d = random.randint(0, len(q)-1)
            if q[d] > 0:
                q[d] = -(random.randint(0, 9))
                otr+=1
                pol-=1
            else:
                pass

        print(numpy.array(q), pol, otr)
        
17. Заполните массив случайным образом нулями, единицами и двойками так, чтобы первая двойка в массиве встречалась раньше первой единицы, количество единиц было в точности равно суммарному количеству нулей и двоек.
        import numpy ## Ебанный рот этого казино, я создал код нагружающий комп до упора, из за этого решение этой задачки не сохранилось, будьте осторожны и сто раз подумайте перед запуском этого кода
        import random

        q = []

        for i in range(0, random.randint(10, 20)):
            if i==0:
                q.append(5)
            else:
                q.append(random.randint(0, 9))

        for j in q:
            if j*3>9:
                q.append(j*3)
            else:
                pass

        print(numpy.array(q), len(q), q.count(1), q.count(0), q.count(2))
        ######
        import numpy ##решение этой задачки
        import random

        q = []

        for i in range(0, random.randint(10, 20)):
                q.append(random.choice([0, 2]))

        while q.count(1)!=q.count(0)+q.count(2):
            q[random.randint(q.index(2)+1, len(q)-1)] = 1

        print(numpy.array(q), len(q), q.count(1), q.count(0), q.count(2))

18. Придумайте правило генерации массива заданной длины. Определите, сгенерирован ли данный массив вашим правилом или нет.
        import numpy ##К черту это придумывание, все что я створю превращается в оружие, rofl))
        import random

        q = []

        for i in range(0, random.randint(10, 20)):
            if i==0:
                q.append(5)
            else:
                q.append(random.randint(0, 9))

        for j in q:
            if j*3>9:
                q.append(j*3)
            else:
                pass

        print(numpy.array(q), len(q), q.count(1), q.count(0), q.count(2))

Анализ элементов массива
19. Определить, содержит ли массив данное число x
        import numpy
        import random

        a = int(input("Number 1: "))
        q = []

        for i in range(0, random.randint(10, 20)):
                q.append(random.randint(0, 99))

        if a in q:
                print("Это число содердится в массиве", numpy.array(q))
        else:
                print("Это число Не содежится в массиве", numpy.array(q))

20. Найти количество четных чисел в массиве.
        import numpy
        import random

        q = []

        for i in range(0, random.randint(10, 20)):
                q.append(random.randint(0, 99))

        print(numpy.array(q))
        print("Четные числа массива: ")

        for i in q:
                if i%2==0:
                        print(i)
                else:
                        pass
                        
21. Найти количество чисел в массиве, которые делятся на 3, но не делятся на 7.
        import numpy
        import random

        q = []

        for i in range(0, random.randint(10, 20)):
                q.append(random.randint(0, 99))

        print(numpy.array(q))
        print("Числа массива, которые делятся на 3, но не делятся на 7: ")

        for i in q:
                if i%3==0 and i%7!=0:
                        print(i)
                else:
                        pass

22. Определите, каких чисел в массиве больше: которые делятся на первый элемент массива или которые делятся на последний элемент массива.
        import numpy
        import random

        q = []

        def ss(x):
                q0 = []
                for i in q:
                        if i%q[x]==0:
                                q0.append(i)
                return q0

        for i in range(0, random.randint(10, 20)):
                q.append(random.randint(0, 999))

        print(q)
        print("Числа массива которые делятся на первое число массива:", len(ss(0)))
        print("Числа массива которые делятся на последнее число массива:", len(ss(-1)))

23. Найдите сумму и произведение элементов массива.
        import numpy
        import random

        q = []

        for i in range(0, random.randint(10, 20)):
                q.append(random.randint(0, 999))

        print(numpy.array(q))
        print("Сумма всех чисел массива:", sum(q))
        print("Произведение всех числе массива:", numpy.prod(numpy.array(q)))

24. Найдите сумму четных чисел массива.
        import numpy
        import random

        q = []

        def ss():
                q0 = []
                for i in q:
                        if i%2==0:
                                q0.append(i)
                return sum(q0)

        for i in range(0, random.randint(10, 20)):
                q.append(random.randint(0, 999))

        print(numpy.array(q))
        print("Сумма четных чисел массива:", ss())
        
25. Найдите сумму нечетных чисел массива, которые не превосходят 11.
        import numpy
        import random

        q = []

        def ss():
                q0 = []
                for i in q:
                        if i%3==0 and i<11:
                                q0.append(i)
                return sum(q0)

        for i in range(0, random.randint(10, 20)):
                q.append(random.randint(0, 99))

        print(numpy.array(q))
        print("Сумма нечетных чисел массива, которые не превосходят 11:", ss())
        
26. Найдите сумму чисел массива, которые расположены до первого четного числа массива. Если четных чисел в массиве нет, то найти сумму всех чисел за исключением крайних.
        import numpy as np
        import random

        q = []
        e = []

        for i in range(0, random.randint(10, 20)):
                q.append(random.randint(0, 99))

        for j in q:
                if j%2==0:
                        e.append(j)
                        break
                else:
                        pass

        if len(e)==0:
                print(q)
                print(e)
                print(np.array(q[0:-1]))
        else:
                print(q)
                print(e)
                print(np.array(q[:(q.index(e[0]))]))
                print(sum(q[:(q.index(e[0]))]))

27. Найдите сумму чисел массива, которые стоят на четных местах.
        import numpy as np
        import random

        q = []
        e = []

        for i in range(0, random.randint(10, 20)):
                q.append(random.randint(0, 99))

        for j in q:
                if j%2==0:
                        e.append(j)
                else:
                        pass

        print(sum(e))
        
28. Найдите сумму чисел массива, которые стоят на нечетных местах и при этом превосходят сумму крайних элементов массива.
        import numpy as np
        import random

        q = []
        e = []

        for i in range(0, random.randint(10, 20)):
                q.append(random.randint(0, 99))

        for j in q:
                if j%2==0 and j>q[0] and j>q[-1]:
                        e.append(j)
                else:
                        pass

        print(q, e, sum(e))
        
29. Дан массив x из n элементов. Найдите x1−x2+x3−…−xn−1+xn.
        import numpy as np ##Чо бля? вроде так
        import random

        n = int(input("Number n: "))

        q = [random.randint(0, 99) for i in range(0, n)]
        e = q[0]
        i = 1

        while i<(n-1)/2:
                e -= q[i] + q[i+1]
                i += 1

        print(e)

30. Дан массив x из n элементов. Найдите x1xn+x2xn−1+…+xnx1.
        import numpy as np
        import random

        n = int(input("Number n: "))

        q = [random.randint(0, 99) for i in range(0, n)]
        e = 0

        for i in range(1, len(q)):
                e += q[i-1]*q[-1*i]

        print(e)
        
31. Дан массив x из n элементов. Найдите xn(xn+xn−1)(xn+xn−1+xn−2)…(xn+…+x1).
        ## Я так заебанный, оставлю на потом

32. Найти наибольший элемент массива.
        import numpy as np
        import random

        n = int(input("Number n: "))

        q = [random.randint(0, 99) for i in range(0, n)]

        print(q, max(q))

33. Найдите сумму наибольшего и наименьшего элементов массива.
        import numpy as np
        import random

        n = int(input("Number n: "))

        q = [random.randint(0, 99) for i in range(0, n)]

        print(q, max(q)+min(q))
        
34. Найдите количество элементов массива, которые отличны от наибольшего элемента не более чем на 10%.
        import numpy as np
        import random

        n = int(input("Number n: "))

        q = [random.randint(0, 99) for i in range(0, n)]
        e = []

        for j in q:
                if ((max(q)-j)*100)/max(q)<10:
                        e.append(j)
                else:
                        pass

        print(q, max(q))
        print(e)
        
35. Найдите наименьший четный элемент массива.
        import numpy as np
        import random

        n = int(input("Number n: "))

        q = [random.randint(0, 99) for i in range(0, n)]
        e = []

        for j in q:
                if j%2 == 0:
                        e.append(j)
                else:
                        pass

        print(min(e))
        
36. Среди элементов с нечетными номерами найдите наибольший элемент массива, который делится на 3.
        import numpy as np
        import random

        n = int(input("Number n: "))

        q = [random.randint(0, 99) for i in range(0, n)]
        e = []

        for j in range(1, len(q)+1):
                if j%2 == 0:
                        pass
                else:
                        if q[j-1]%3==0:
                                e.append(q[j-1])
                        else:
                                pass

        print(q, (e), max(e))
        
37. Дан массив и число p. Найдите два различных числа в массиве, сумма которых наиболее близка к p.
        import numpy as np
        import random

        p = int(input("Number p: "))
        n = int(input("Number n: "))

        q = [random.randint(0, 99) for i in range(0, n)]
        e = []


        for i in q:
                for j in q:
                        if abs(p-(i+j))<5:
                                print(i, j)
                        else:
                                pass
                                
38. Дан массив. Найдите два соседних элемента, сумма которых минимальна.
        ##Не могу понять дано
        
39. Дан массив. Найдите три последовательных элемента в массиве, сумма которых максимальна.
        import numpy as np ##Коды все грязнее и грязнее
        import random

        n = int(input("Number n: "))

        q = [random.randint(0, 99) for i in range(0, n)]
        e = []


        for i in range(2, len(q)):
                w = q[i-2]+q[i-1]+q[i]
                e.append(w)

        m = e.index(max(e))

        print(q)
        print(e, max(e), m)
        print(q[m], q[m+1], q[m+2])
        
40. В данном массиве найдите количество чисел, соседи у которых отличаются более чем в 2 раза.
        import numpy as np ##Тестировался не доконца, возможно проблемы с нулем, можно исправить с try-except
        import random

        n = int(input("Number n: "))

        q = [random.randint(0, 99) for i in range(0, n)]
        e = []


        for i in range(1, len(q)):
                if q[i-2]/2>q[i-1] or q[i-1]<q[i]/2:
                        e.append(q[i-1])
                else:
                        pass

        print(q)
        print(e)

41. Найдите количество чисел, каждое из которых равно сумме квадратов своих соседей и при этом не является наибольшим в массиве.
        import numpy as np ##Досконально не проверял, если что то не так дайте мне знать
        import random

        n = int(input("Number n: "))

        q = [random.randint(0, 99) for i in range(0, n)]
        e = []

        for i in range(2, len(q)):
                if (q[i-2]**2)+(q[i]**2)==q[i-1] and q[i-1]!=max(q):
                        e.append(q[i-1])
                else:
                        pass
        if len(e)==0:
                print("Таких чисел в массиве нет")
        else:
                print(q)
                print(e)
                
42. Проверьте, содержит ли данный массив из n чисел, все числа от 1 до n.
        import numpy as np
        import random

        n = int(input("Number n: "))

        q = [random.randint(0, n) for i in range(0, n)]
        numbers = [j for j in range(0, n)]

        for i in set(q):
            if i in numbers:
                numbers.remove(i)

        if len(numbers)!=0:
            print("Массив не содержит все числа от 0 до %d"%n)
            print(q, len(q))
            print("Числа которые не содержится в массиве:", numbers)
        elif len(numbers)==0:
            print(q)
            print(numbers)
            print("Массив имеет все числа от 0 до %d"%n)
            
43. Проверьте, образует ли элементы массива в данном порядке арифметическую или геометрическую прогрессии.
        import numpy as np ##Нах я не использовал нумпи?
        import random

        f  = []

        for i in range(1, 20):
            if i == 1:
                f.append(2)
            else:
                f.append(f[-1]*1/2)

        i = 0

        def ar():
            d = f[1] - f[0]

            check = []

            for i in range(0, 20-1):
                if i == 0:
                    check.append(f[0])
                else:
                    check.append(check[-1]+d)

            if f == check:
                if d>0:
                    print("+")
                else:
                    print("-")
            else:
                geom()

        def geom():
            q = f[1] / f[0]

            check = []

            for i in range(0, 20-1):
                if i == 0:
                    check.append(f[0])
                else:
                    check.append(check[-1]*q)

            if f == check:
                if abs(q)>1:
                    print("Возрастающая геом прог")
                elif abs(q)<1:
                    print("Убывающая геом прог")
            else:
                print("Массив не является ни арифметической ни геометрической прогрессией")

        ar()
        print(f)

44. Проверьте, является ли данный массив возрастающим или убывающим.
        import numpy as np
        import random

        f  = []
        j = 0

        while j<10:
            a = int(input("GET: "))
            f.append(a)
            j+=1

        def pol():
            i = 1

            check = True

            while i<len(f):
                if i == 0:
                    check = True
                    i+=1
                elif f[i]>=f[i-1]:
                    check = True
                    i+=1
                else:
                    check = False
                    break

            if check:
                print("Массив является положительным")
            else:
                otr()

        def otr():
            i = 1

            check = True

            while i<len(f):
                if i == 0:
                    check = True
                    i+=1
                elif f[i]<=f[i-1]:
                    check = True
                    i+=1
                else:
                    check = False
                    break

            if check:
                print("Массив является отрицательным")
            else:
                print("Массив является смешанным")

        pol()
        
45. Найдите количество различных элементов данного массива.
        import numpy as np
        import random

        f  = []
        j = 0

        while j<10:
            a = int(input("GET: "))
            f.append(a)
            j+=1

        print(set(f))

46. Определите количество перемен знаков элементов массива.
        import numpy as np
        import random

        f  = []

        otr = []
        pol = []
        j = 0

        while j<10:
            a = int(input("GET: "))
            f.append(a)
            j+=1

        for i in f:
            if i<0:
                otr.append(i)
            else:
                pol.append(i)

        print("Количество отрицательных чисел в массиве:", len(otr), otr)
        print("Количество положительных чисел в массиве:", len(pol), pol)
        
47. В данном массиве найти максимальное количество одинаковых элементов.
        import numpy as np
        import random

        f  = []
        j = 0

        while j<10:
            a = int(input("GET: "))
            f.append(a)
            j+=1

        l = set(f)
        digit = []

        for i in l:
            a = f.count(i)
            digit.append([i, a])

        r = max(digit, key=lambda i: i[1])

        print(digit)
        print("Максимальное количество одиннаковых чисел {0}, это число {1}".format(r[0], r[1]))

48. Найти наиболее часто встречающийся элемент в массиве целых чисел.
        ##Решение на 47 принт {1}

49. В одномерном массиве, состоящем из n вещественных элементов, вычислите номер минимального элемента массива и сумму элементов массива, расположенных между первым и вторым отрицательными элементами.
        import numpy as np
        import random

        f  = []

        j = 0
        while j<10:
            a = int(input("GET: "))
            f.append(a)
            j+=1

        minmin = f.index(min(f))+1

        per = []

        for i, t in enumerate(f):
            if t<0:
                per.append(i)
            elif len(per) == 2:
                break
            else:
                pass

        print("Номер минимального элемента(В человеческом рассчете):", minmin)
        print(per)
        print("Сумма чисел между первого отрицательного числа и второго:", sum(f[per[0]+1:per[1]]))

50. Напишите программу, которая вводит с клавиатуры непустой массив целых чисел, и выводит число локальных максимумов (элемент является локальным максимумом, если он не имеет соседей, больших, чем он сам).
        import numpy as np
        import random

        f  = []
        l = 0

        while l<10:
            a = int(input("GET: "))
            f.append(a)
            l+=1

        e = []
        i = 0

        while i<len(f):
            if i == 0:
                i+=1
            elif i == len(f)-1:
                if f[i-1]<f[i] and f[i]>f[i+1]:
                    e.append([f[i], i])
                    break
                else:
                    break
            else:
                if f[i-1]<f[i] and f[i]>f[i+1]:
                    e.append([f[i], i])
                    i+=1
                else:
                    i+=1

        print(f)
        print("Цифры, которые больше соседей и их индекс:", e)
        
51. В данном массиве найдите два наименьших элемента.
        import numpy as np
        import random

        f  = []
        l = 0

        while l<10:
            a = int(input("GET: "))
            f.append(a)
            l+=1

        e = sorted(f)

        print(e[0], e[1])
        
52. Определите, есть ли в массиве повторяющиеся элементы.
        import numpy as np
        import random

        f  = []
        l = 0

        while l<10:
            a = int(input("GET: "))
            f.append(a)
            l+=1

        e = set(f)

        if f == e:
            print("Повторяющиеся элементов нет")
        else:
            print("Повторяющиеся элементы есть")

53. В данном массиве найдите наибольшую серию подряд идущих элементов, расположенных по возрастанию.
        import numpy as np ##ДААА!!! КАК ЖЕ МНОГО ВРЕМЕНИ я ПОТЕРЯЛ
        import random

        f  = [random.randint(1, 99) for i in range(100)]

        i = 0

        start = 0
        lenght = 1
        max_start = 0
        max_lenght = 0

        while i<len(f)-1:
            if i == len(f)-2:
                if f[i]<f[i+1]:
                    lenght+=1
                    if lenght>max_lenght:
                        max_lenght = lenght
                        max_start = start
                    i+=1
                else:
                    if lenght>max_lenght:
                        max_lenght = lenght
                        max_start = start
                    i+=1
            elif f[i]<f[i+1]:
                lenght+=1
                i+=1
            else:
                if lenght>max_lenght:
                    max_lenght = lenght
                    max_start = start
                lenght = 1
                start = i + 1
                i+=1

        print(start, lenght, max_start, max_lenght)
        print(f)
        print(len(f))

        for p in range(max_start, max_start+max_lenght):
            print(f[p], end=" ")
