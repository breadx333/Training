1. Заполнить массив нулями, кроме первого и последнего элементов, которые должны быть равны единице.
        a = int(input())

        q = []

        for i in range(0, a):
            if i==0:
                q.append(-1)
            elif i==a-1:
                q.append(1)
            else:
                q.append(0)

        print(numpy.array(q))

2. Заполнить массив нулями и единицами, при этом данные значения чередуются, начиная с нуля.
        a = int(input(""))

        q = []

        for i in range(0, a):
                if i%2==0:
                    q.append(0)
                else:
                    q.append(1)
        
        print(numpy.array(q))

3. Заполнить массив последовательными нечетными числами, начиная с единицы.
        a = int(input(""))

        q = []

        for i in range(0, a):
                if i%2==0:
                    pass
                else:
                    q.append(i)

        print(numpy.array(q))

4. Сформировать массив из элементов арифметической прогрессии с заданным первым элементом x и разностью d.
        import numpy

        a = int(input("Начиная от: "))
        b = int(input("До: "))
        d = int(input("Разность числел: "))

        q = []

        if a>b:
            b = b-2
            d = -d
        for i in range(a, b+1, d):
            q.append(i)

        print(numpy.array(q))
        
5. Сформировать возрастающий массив из четных чисел.
        import numpy

        a = int(input("Начиная от: "))
        b = int(input("До: "))

        q = []

        for i in range(a, b+1):
            if i%2==0:
                q.append(i)

        print(numpy.array(q))
        
6. Сформировать убывающий массив из чисел, которые делятся на 3.
        import numpy

        a = int(input("Начиная от: "))
        b = int(input("До: "))

        q = []

        for i in reversed(range(a, b+1)):
            if i%3==0:
                q.append(i)

        print("Данные идут по убыванию", numpy.array(q))
        
7. Создать массив из n первых чисел Фибоначчи.
        import numpy

        a = int(input("Длина Фибоначчи: "))

        q = [0, 1]

        fib1 = q[-2]
        fib2 = q[-1]

        for i in range(a-2):
            summa = fib1 + fib2
            fib1 = fib2
            fib2 = summa
            q.append(summa)

        print(numpy.array(q))

8. Заполнить массив заданной длины различными простыми числами. Натуральное число, большее единицы, называется простым, если оно делится только на себя и на единицу.
        import numpy
        import random

        a = int(input("Длина Фибоначчи: "))

        q = []
        d = []

        for i in range(1, 1000):
            f = []
            for j in range(1, 1000):
                if i%j==0:
                    f.append(i)
            if len(f)==2:
                d.append(i)

        for k in range(0, a):
            q.append(random.choice(d))

        print(numpy.array(q))
        
9. Создать массив, каждый элемент которого равен квадрату своего номера.
        import numpy
        import random

        a = int(input("Длина Фибоначчи: "))

        q = []

        for i in range(0, a):
            q.append(i*i)

        print(numpy.array(q))
        
10. Создать массив, на четных местах в котором стоят единицы, а на нечетных местах - числа, равные остатку от деления своего номера на 5.
        import numpy ##Хз, наверное будет так
        import random

        a = int(input("Длина Фибоначчи: "))

        q = []

        for i in range(0, a):
            if i%2==0:
                q.append(1)
            else:
                l = i%5
                q.append(l)

        print(q)
        
11. Создать массив, состоящий из троек подряд идущих одинаковых элементов.
        import numpy
        import random

        a = int(input("Длина Фибоначчи: "))

        q = []

        for i in range(0, a):
            l = random.randint(1, 999)
            for j in range(0, 3):
                q.append(l)

        print(numpy.array(q))

12. Создать массив, который одинаково читается как слева направо, так и справа налево.
        import numpy
        import random

        a = int(input("Длина Фибоначчи: "))

        q = []

        for i in range(0, a):
            l = random.randint(1, 999)
            q.append(l)

        w = q + q[::-1]

        print(numpy.array(w))
        
13. Сформировать массив из случайных чисел, в которых ровно две единицы, стоящие на случайных позициях.
        import numpy
        import random

        a = int(input("Длина Фибоначчи: "))

        q = []

        for i in range(0, a):
            l = random.randint(1, 999)
            q.append(l)

        if len(q)==1:
            q = [1]
        else:
            while q.count(1)<2:
                q[random.randint(0, len(q)-1)] = 1

        print(numpy.array(q))
        
14. Заполните массив случайным образом нулями и единицами так, чтобы количество единиц было больше количества нулей.
        import numpy
        import random

        q = []

        for i in range(0, random.randint(1, 100)):
            l = 0
            q.append(l)

        while q.count(1)<=q.count(0):
            q[random.randint(0, len(q)-1)] = 1

        print(numpy.array(q), q.count(1), q.count(0))

15. Сформировать массив из случайных целых чисел от 0 до 9 , в котором единиц от 3 до 5 и двоек больше троек.
        import numpy ##Я знаю что этот код можно написать более оптимизировано, но пока так, еще у меня как всегда сезонно начал забиватся нос
        import random

        q = []
        d = random.randint(3, 5)

        for i in range(0, random.randint(1, 100)):
            l = random.randint(0, 9)
            q.append(l)

        while 3>q.count(1):
            q[random.randint(0, len(q)-1)] = 1

        while 5<q.count(1):
            if q[random.randint(0, len(q)-1)] == 1:
                q[random.randint(0, len(q)-1)] = random.randint(0, 9)
            else:
                pass

        while q.count(2)<=q.count(3):
            l = random.randint(0, len(q)-1)
            if q[l]!=1:
                q[l] = 2
            else:
                pass

        print(numpy.array(q), q.count(1), q.count(2), q.count(3))
        
16. Создайте массив, в котором количество отрицательных чисел равно количеству положительных и положительные числа расположены на случайных местах в массиве.
        import numpy ##Код рабочий, но с каким то багом, он иногда не работает, не разобрался почему
        import random

        q = []
        pol = 0
        otr = 0

        for i in range(0, random.randint(2, 100)):
            l = random.randint(0, 9)
            q.append(l)
            pol+=1

        while otr!=pol:
            d = random.randint(0, len(q)-1)
            if q[d] > 0:
                q[d] = -(random.randint(0, 9))
                otr+=1
                pol-=1
            else:
                pass

        print(numpy.array(q), pol, otr)
        
17. Заполните массив случайным образом нулями, единицами и двойками так, чтобы первая двойка в массиве встречалась раньше первой единицы, количество единиц было в точности равно суммарному количеству нулей и двоек.
        import numpy ## Ебанный рот этого казино, я создал код нагружающий комп до упора, из за этого решение этой задачки не сохранилось, будьте осторожны и сто раз подумайте перед запуском этого кода
        import random

        q = []

        for i in range(0, random.randint(10, 20)):
            if i==0:
                q.append(5)
            else:
                q.append(random.randint(0, 9))

        for j in q:
            if j*3>9:
                q.append(j*3)
            else:
                pass

        print(numpy.array(q), len(q), q.count(1), q.count(0), q.count(2))
        ######
        import numpy ##решение этой задачки
        import random

        q = []

        for i in range(0, random.randint(10, 20)):
                q.append(random.choice([0, 2]))

        while q.count(1)!=q.count(0)+q.count(2):
            q[random.randint(q.index(2)+1, len(q)-1)] = 1

        print(numpy.array(q), len(q), q.count(1), q.count(0), q.count(2))

18. Придумайте правило генерации массива заданной длины. Определите, сгенерирован ли данный массив вашим правилом или нет.
        import numpy ##К черту это придумывание, все что я створю превращается в оружие, rofl))
        import random

        q = []

        for i in range(0, random.randint(10, 20)):
            if i==0:
                q.append(5)
            else:
                q.append(random.randint(0, 9))

        for j in q:
            if j*3>9:
                q.append(j*3)
            else:
                pass

        print(numpy.array(q), len(q), q.count(1), q.count(0), q.count(2))

Анализ элементов массива
19. Определить, содержит ли массив данное число x
        import numpy
        import random

        a = int(input("Number 1: "))
        q = []

        for i in range(0, random.randint(10, 20)):
                q.append(random.randint(0, 99))

        if a in q:
                print("Это число содердится в массиве", numpy.array(q))
        else:
                print("Это число Не содежится в массиве", numpy.array(q))

20. Найти количество четных чисел в массиве.
        import numpy
        import random

        q = []

        for i in range(0, random.randint(10, 20)):
                q.append(random.randint(0, 99))

        print(numpy.array(q))
        print("Четные числа массива: ")

        for i in q:
                if i%2==0:
                        print(i)
                else:
                        pass
                        
21. Найти количество чисел в массиве, которые делятся на 3, но не делятся на 7.
        import numpy
        import random

        q = []

        for i in range(0, random.randint(10, 20)):
                q.append(random.randint(0, 99))

        print(numpy.array(q))
        print("Числа массива, которые делятся на 3, но не делятся на 7: ")

        for i in q:
                if i%3==0 and i%7!=0:
                        print(i)
                else:
                        pass

22. Определите, каких чисел в массиве больше: которые делятся на первый элемент массива или которые делятся на последний элемент массива.
        import numpy
        import random

        q = []

        def ss(x):
                q0 = []
                for i in q:
                        if i%q[x]==0:
                                q0.append(i)
                return q0

        for i in range(0, random.randint(10, 20)):
                q.append(random.randint(0, 999))

        print(q)
        print("Числа массива которые делятся на первое число массива:", len(ss(0)))
        print("Числа массива которые делятся на последнее число массива:", len(ss(-1)))

23. Найдите сумму и произведение элементов массива.
        import numpy
        import random

        q = []

        for i in range(0, random.randint(10, 20)):
                q.append(random.randint(0, 999))

        print(numpy.array(q))
        print("Сумма всех чисел массива:", sum(q))
        print("Произведение всех числе массива:", numpy.prod(numpy.array(q)))

24. Найдите сумму четных чисел массива.
        import numpy
        import random

        q = []

        def ss():
                q0 = []
                for i in q:
                        if i%2==0:
                                q0.append(i)
                return sum(q0)

        for i in range(0, random.randint(10, 20)):
                q.append(random.randint(0, 999))

        print(numpy.array(q))
        print("Сумма четных чисел массива:", ss())
        
25. Найдите сумму нечетных чисел массива, которые не превосходят 11.
        import numpy
        import random

        q = []

        def ss():
                q0 = []
                for i in q:
                        if i%3==0 and i<11:
                                q0.append(i)
                return sum(q0)

        for i in range(0, random.randint(10, 20)):
                q.append(random.randint(0, 99))

        print(numpy.array(q))
        print("Сумма нечетных чисел массива, которые не превосходят 11:", ss())
        
26. Найдите сумму чисел массива, которые расположены до первого четного числа массива. Если четных чисел в массиве нет, то найти сумму всех чисел за исключением крайних.
        import numpy as np
        import random

        q = []
        e = []

        for i in range(0, random.randint(10, 20)):
                q.append(random.randint(0, 99))

        for j in q:
                if j%2==0:
                        e.append(j)
                        break
                else:
                        pass

        if len(e)==0:
                print(q)
                print(e)
                print(np.array(q[0:-1]))
        else:
                print(q)
                print(e)
                print(np.array(q[:(q.index(e[0]))]))
                print(sum(q[:(q.index(e[0]))]))

27. Найдите сумму чисел массива, которые стоят на четных местах.
        import numpy as np
        import random

        q = []
        e = []

        for i in range(0, random.randint(10, 20)):
                q.append(random.randint(0, 99))

        for j in q:
                if j%2==0:
                        e.append(j)
                else:
                        pass

        print(sum(e))
        
28. Найдите сумму чисел массива, которые стоят на нечетных местах и при этом превосходят сумму крайних элементов массива.
        import numpy as np
        import random

        q = []
        e = []

        for i in range(0, random.randint(10, 20)):
                q.append(random.randint(0, 99))

        for j in q:
                if j%2==0 and j>q[0] and j>q[-1]:
                        e.append(j)
                else:
                        pass

        print(q, e, sum(e))
        
29. Дан массив x из n элементов. Найдите x1−x2+x3−…−xn−1+xn.
        import numpy as np ##Чо бля? вроде так
        import random

        n = int(input("Number n: "))

        q = [random.randint(0, 99) for i in range(0, n)]
        e = q[0]
        i = 1

        while i<(n-1)/2:
                e -= q[i] + q[i+1]
                i += 1

        print(e)

30. Дан массив x из n элементов. Найдите x1xn+x2xn−1+…+xnx1.
        import numpy as np
        import random

        n = int(input("Number n: "))

        q = [random.randint(0, 99) for i in range(0, n)]
        e = 0

        for i in range(1, len(q)):
                e += q[i-1]*q[-1*i]

        print(e)
        
31. Дан массив x из n элементов. Найдите xn(xn+xn−1)(xn+xn−1+xn−2)…(xn+…+x1).
        ## Я так заебанный, оставлю на потом

32. Найти наибольший элемент массива.
        import numpy as np
        import random

        n = int(input("Number n: "))

        q = [random.randint(0, 99) for i in range(0, n)]

        print(q, max(q))

33. Найдите сумму наибольшего и наименьшего элементов массива.
        import numpy as np
        import random

        n = int(input("Number n: "))

        q = [random.randint(0, 99) for i in range(0, n)]

        print(q, max(q)+min(q))
        
34. Найдите количество элементов массива, которые отличны от наибольшего элемента не более чем на 10%.
        import numpy as np
        import random

        n = int(input("Number n: "))

        q = [random.randint(0, 99) for i in range(0, n)]
        e = []

        for j in q:
                if ((max(q)-j)*100)/max(q)<10:
                        e.append(j)
                else:
                        pass

        print(q, max(q))
        print(e)
        
35. Найдите наименьший четный элемент массива.
        import numpy as np
        import random

        n = int(input("Number n: "))

        q = [random.randint(0, 99) for i in range(0, n)]
        e = []

        for j in q:
                if j%2 == 0:
                        e.append(j)
                else:
                        pass

        print(min(e))
        
36. Среди элементов с нечетными номерами найдите наибольший элемент массива, который делится на 3.
        import numpy as np
        import random

        n = int(input("Number n: "))

        q = [random.randint(0, 99) for i in range(0, n)]
        e = []

        for j in range(1, len(q)+1):
                if j%2 == 0:
                        pass
                else:
                        if q[j-1]%3==0:
                                e.append(q[j-1])
                        else:
                                pass

        print(q, (e), max(e))
        
37. Дан массив и число p. Найдите два различных числа в массиве, сумма которых наиболее близка к p.
        import numpy as np
        import random

        p = int(input("Number p: "))
        n = int(input("Number n: "))

        q = [random.randint(0, 99) for i in range(0, n)]
        e = []


        for i in q:
                for j in q:
                        if abs(p-(i+j))<5:
                                print(i, j)
                        else:
                                pass
                                
38. Дан массив. Найдите два соседних элемента, сумма которых минимальна.
        ##Не могу понять дано
        
39. Дан массив. Найдите три последовательных элемента в массиве, сумма которых максимальна.
        import numpy as np ##Коды все грязнее и грязнее
        import random

        n = int(input("Number n: "))

        q = [random.randint(0, 99) for i in range(0, n)]
        e = []


        for i in range(2, len(q)):
                w = q[i-2]+q[i-1]+q[i]
                e.append(w)

        m = e.index(max(e))

        print(q)
        print(e, max(e), m)
        print(q[m], q[m+1], q[m+2])
        
40. В данном массиве найдите количество чисел, соседи у которых отличаются более чем в 2 раза.
        import numpy as np ##Тестировался не доконца, возможно проблемы с нулем, можно исправить с try-except
        import random

        n = int(input("Number n: "))

        q = [random.randint(0, 99) for i in range(0, n)]
        e = []


        for i in range(1, len(q)):
                if q[i-2]/2>q[i-1] or q[i-1]<q[i]/2:
                        e.append(q[i-1])
                else:
                        pass

        print(q)
        print(e)

41. Найдите количество чисел, каждое из которых равно сумме квадратов своих соседей и при этом не является наибольшим в массиве.
        import numpy as np ##Досконально не проверял, если что то не так дайте мне знать
        import random

        n = int(input("Number n: "))

        q = [random.randint(0, 99) for i in range(0, n)]
        e = []

        for i in range(2, len(q)):
                if (q[i-2]**2)+(q[i]**2)==q[i-1] and q[i-1]!=max(q):
                        e.append(q[i-1])
                else:
                        pass
        if len(e)==0:
                print("Таких чисел в массиве нет")
        else:
                print(q)
                print(e)
                
42. Проверьте, содержит ли данный массив из n чисел, все числа от 1 до n.
        import numpy as np
        import random

        n = int(input("Number n: "))

        q = [random.randint(0, n) for i in range(0, n)]
        numbers = [j for j in range(0, n)]

        for i in set(q):
            if i in numbers:
                numbers.remove(i)

        if len(numbers)!=0:
            print("Массив не содержит все числа от 0 до %d"%n)
            print(q, len(q))
            print("Числа которые не содержится в массиве:", numbers)
        elif len(numbers)==0:
            print(q)
            print(numbers)
            print("Массив имеет все числа от 0 до %d"%n)
            
43. Проверьте, образует ли элементы массива в данном порядке арифметическую или геометрическую прогрессии.
        import numpy as np ##Нах я не использовал нумпи?
        import random

        f  = []

        for i in range(1, 20):
            if i == 1:
                f.append(2)
            else:
                f.append(f[-1]*1/2)

        i = 0

        def ar():
            d = f[1] - f[0]

            check = []

            for i in range(0, 20-1):
                if i == 0:
                    check.append(f[0])
                else:
                    check.append(check[-1]+d)

            if f == check:
                if d>0:
                    print("+")
                else:
                    print("-")
            else:
                geom()

        def geom():
            q = f[1] / f[0]

            check = []

            for i in range(0, 20-1):
                if i == 0:
                    check.append(f[0])
                else:
                    check.append(check[-1]*q)

            if f == check:
                if abs(q)>1:
                    print("Возрастающая геом прог")
                elif abs(q)<1:
                    print("Убывающая геом прог")
            else:
                print("Массив не является ни арифметической ни геометрической прогрессией")

        ar()
        print(f)

44. Проверьте, является ли данный массив возрастающим или убывающим.
        import numpy as np
        import random

        f  = []
        j = 0

        while j<10:
            a = int(input("GET: "))
            f.append(a)
            j+=1

        def pol():
            i = 1

            check = True

            while i<len(f):
                if i == 0:
                    check = True
                    i+=1
                elif f[i]>=f[i-1]:
                    check = True
                    i+=1
                else:
                    check = False
                    break

            if check:
                print("Массив является положительным")
            else:
                otr()

        def otr():
            i = 1

            check = True

            while i<len(f):
                if i == 0:
                    check = True
                    i+=1
                elif f[i]<=f[i-1]:
                    check = True
                    i+=1
                else:
                    check = False
                    break

            if check:
                print("Массив является отрицательным")
            else:
                print("Массив является смешанным")

        pol()
        
45. Найдите количество различных элементов данного массива.
        import numpy as np
        import random

        f  = []
        j = 0

        while j<10:
            a = int(input("GET: "))
            f.append(a)
            j+=1

        print(set(f))

46. Определите количество перемен знаков элементов массива.
        import numpy as np
        import random

        f  = []

        otr = []
        pol = []
        j = 0

        while j<10:
            a = int(input("GET: "))
            f.append(a)
            j+=1

        for i in f:
            if i<0:
                otr.append(i)
            else:
                pol.append(i)

        print("Количество отрицательных чисел в массиве:", len(otr), otr)
        print("Количество положительных чисел в массиве:", len(pol), pol)
        
47. В данном массиве найти максимальное количество одинаковых элементов.
        import numpy as np
        import random

        f  = []
        j = 0

        while j<10:
            a = int(input("GET: "))
            f.append(a)
            j+=1

        l = set(f)
        digit = []

        for i in l:
            a = f.count(i)
            digit.append([i, a])

        r = max(digit, key=lambda i: i[1])

        print(digit)
        print("Максимальное количество одиннаковых чисел {0}, это число {1}".format(r[0], r[1]))

48. Найти наиболее часто встречающийся элемент в массиве целых чисел.
        ##Решение на 47 принт {1}

49. В одномерном массиве, состоящем из n вещественных элементов, вычислите номер минимального элемента массива и сумму элементов массива, расположенных между первым и вторым отрицательными элементами.
        import numpy as np
        import random

        f  = []

        j = 0
        while j<10:
            a = int(input("GET: "))
            f.append(a)
            j+=1

        minmin = f.index(min(f))+1

        per = []

        for i, t in enumerate(f):
            if t<0:
                per.append(i)
            elif len(per) == 2:
                break
            else:
                pass

        print("Номер минимального элемента(В человеческом рассчете):", minmin)
        print(per)
        print("Сумма чисел между первого отрицательного числа и второго:", sum(f[per[0]+1:per[1]]))

50. Напишите программу, которая вводит с клавиатуры непустой массив целых чисел, и выводит число локальных максимумов (элемент является локальным максимумом, если он не имеет соседей, больших, чем он сам).
        import numpy as np
        import random

        f  = []
        l = 0

        while l<10:
            a = int(input("GET: "))
            f.append(a)
            l+=1

        e = []
        i = 0

        while i<len(f):
            if i == 0:
                i+=1
            elif i == len(f)-1:
                if f[i-1]<f[i] and f[i]>f[i+1]:
                    e.append([f[i], i])
                    break
                else:
                    break
            else:
                if f[i-1]<f[i] and f[i]>f[i+1]:
                    e.append([f[i], i])
                    i+=1
                else:
                    i+=1

        print(f)
        print("Цифры, которые больше соседей и их индекс:", e)
        
51. В данном массиве найдите два наименьших элемента.
        import numpy as np
        import random

        f  = []
        l = 0

        while l<10:
            a = int(input("GET: "))
            f.append(a)
            l+=1

        e = sorted(f)

        print(e[0], e[1])
        
52. Определите, есть ли в массиве повторяющиеся элементы.
        import numpy as np
        import random

        f  = []
        l = 0

        while l<10:
            a = int(input("GET: "))
            f.append(a)
            l+=1

        e = set(f)

        if f == e:
            print("Повторяющиеся элементов нет")
        else:
            print("Повторяющиеся элементы есть")

53. В данном массиве найдите наибольшую серию подряд идущих элементов, расположенных по возрастанию.
        import numpy as np ##ДААА!!! КАК ЖЕ МНОГО ВРЕМЕНИ я ПОТЕРЯЛ
        import random

        f  = [random.randint(1, 99) for i in range(100)]

        i = 0

        start = 0
        lenght = 1
        max_start = 0
        max_lenght = 0

        while i<len(f)-1:
            if i == len(f)-2:
                if f[i]<f[i+1]:
                    lenght+=1
                    if lenght>max_lenght:
                        max_lenght = lenght
                        max_start = start
                    i+=1
                else:
                    if lenght>max_lenght:
                        max_lenght = lenght
                        max_start = start
                    i+=1
            elif f[i]<f[i+1]:
                lenght+=1
                i+=1
            else:
                if lenght>max_lenght:
                    max_lenght = lenght
                    max_start = start
                lenght = 1
                start = i + 1
                i+=1

        print(start, lenght, max_start, max_lenght)
        print(f)
        print(len(f))

        for p in range(max_start, max_start+max_lenght):
            print(f[p], end=" ")

54. В массиве найдите количество серий из четверок подряд идущих попарно различных элементов.
        import numpy as np
        import random

        f  = [5, 7, 8, 9, 3, 0, 4, 6, 8, 9, 3, 4, 3, 4, 5, 6, 7, 8, 9, 10]

        i = 0
        e = []

        while i<len(f)-1:
            if f[i+1] == 4:
                e.append([f[i], f[i+1]])
                i+=2
            else:
                i+=1

        print(e)

55. Определите, можно ли вычеркнуть из данного массива одно число так, чтобы оставшиеся числа оказались упорядоченными по возрастанию.
        import numpy as np
        import random

        f  = [5, 7, 8, 9, 3, 0, 4, 6, 8, 9, 3, 4, 3, 4, 5, 6, 7, 8, 9, 10]

        print(f)
        a = int(input("Какой элемент убрать?: "))

        if f[a-1]<f[a] and f[a]<f[a+1] or f[a-1]>f[a]:
            print("Да элемент можно убрать")
        else:
            print("Элемент не убрать, так как порядок возрастания нарушается")
            
Преобразование массива
56. В массиве заменить все числа, большие данного числа, на среднее арифметическое всех чисел массива.
        import numpy as np
        import random

        f  = [5, 7, 8, 9, 3, 0, 4, 6, 8, 9, 3, 4, 3, 4, 5, 6, 7, 8, 9, 10]
        print(f)
        a = int(input("Number: "))
        average = sum(f)/len(f)

        for i, j in enumerate(f):
            if j<a:
                f[i] = average
            else:
                pass

        print(f)

57. Дан массив. Заменить все числа, меньшие последнего элемента массива, на первый элемент.
        import numpy as np
        import random

        f  = [5, 7, 8, 9, 3, 0, 4, 6, 8, 9, 3, 4, 3, 4, 5, 6, 7, 8, 9, 10, 8]
        print(f)

        for i, j in enumerate(f):
            if j<f[-1]:
                f[i] = f[-1]
            else:
                pass

        print(f)
        
58. Поменять местами наибольший и наименьший элементы массива.
        import numpy as np
        import random

        f  = [5, 7, 8, 9, 3, 0, 4, 6, 8, 9, 3, 4, 3, 4, 5, 6, 7, 8, 9, 10, 8]
        print(f)

        first = f[0]
        last = f[-1]

        f[0] = last
        f[-1] = first

        print(f)
        
59. Найти наибольший четный элемент массива и поменять его местами с наименьшим нечетным элементом. Если одного из таких элементов нет, то всем элементам массива присвоить значение, равное нулю.
        import numpy as np
        import random

        f  = [12, 5, 7, 8, 9, 3, 0, 4, 6, 8, 9, 3, 4, 3, 4, 5, 6, 7, 8, 9, 10, 8]
        print(f)

        l = sorted(f)
        max_l = []
        min_r = []

        for i in reversed(l):
            if i%2 == 0:
                max_l.append(i)
                break
            else:
                pass

        for j in l:
            if j%2 == 0:
                min_r.append(j)
                break
            else:
                pass

        if len(max_l)!=0 and len(min_r)!=0:
            f[f.index(max_l[0])] = min_r
            f[f.index(min_r[0])] = max_l
            print(f)
        else:
            f = [0 for i in range(len(f))]
            print(f)
            
60. Заменить каждый элемент массива с четным номером на соседний слева элемент.
        import numpy as np
        import random

        f  = [12, 5, 7, 8, 9, 3, 0, 4, 6, 8, 9, 3, 4, 3, 4, 5, 6, 7, 8, 9, 10, 8]
        print(f)

        for i, j in enumerate(f):
            if i == 0:
                pass
            elif j%2 == 0:
                f[i] = f[i-1]
            else:
                pass

        print(f)
        
61. Удалить в массиве первый и последний элементы.
        import numpy as np
        import random

        f  = [12, 5, 7, 8, 9, 3, 0, 4, 6, 8, 9, 3, 4, 3, 4, 5, 6, 7, 8, 9, 10, 8]
        print(f)

        del f[0]
        del f[-1]

        print(f)
        
62. Удалить в массиве все числа, которые повторяются более двух раз.
        import numpy as np
        import random

        f  = [12, 5, 7, 8, 9, 3, 0, 4, 6, 8, 9, 3, 4, 3, 4, 5, 6, 7, 8, 9, 10, 8]
        print(f)

        for i, j in enumerate(f):
            if f.count(j)>2:
                for k in f:
                    if k == j:
                        f.remove(j)
                    else:
                        pass
            else:
                pass

        print(f)
        
63. Найти в массиве все серии подряд идущих одинаковых элементов и удалить из них все элементы кроме одного.
        import numpy as np
        import random

        f  = [2, 2, 2, 12, 5, 7, 8, 7, 7, 7, 7, 9, 3, 0, 4, 6, 8, 9, 3, 4, 3, 4, 5, 6, 7, 8, 9, 10, 8]
        print(f)

        i = 0

        while i<len(f):
            if f[i] == f[i-1]:
                del f[i]
                i = i
            elif i == len(f)-1:
                if f[i] == f[i-1]:
                    del f[i]
                else:
                    break
            else:
                i+=1

        print(f)
        
64. Удалить в массиве все наибольшие элементы.
        import numpy as np
        import random

        f  = [4, 5, 10, 9, 2, 2, 1, 5, 8, 3, 6, 10]
        print(f)

        max_elem = max(f)

        for i, j in enumerate(f):
            if j == max_elem:
                del f[i]
            else:
                pass

        print(f)
        
65. Переставить элементы массива в обратном порядке.
        import numpy as np
        import random

        f  = [4, 5, 10, 9, 2, 2, 1, 5, 8, 3, 6, 10]
        print(f)

        print(list(reversed(f)))
        
66. Дан массив a из n элементов. Сформировать новый массив b такого же размера так, что элемент bk равен сумме элементов первых элементов массиваa до номера k включительно.
        import numpy as np
        import random

        n = int(input("Number n: "))
        a = [random.randint(0, 9) for i in range(0, n)]

        b = []

        for i in range(0, len(a)):
            b.append(sum(a[:i+1]))

        print(a)
        print(b)
        
67. В данном массиве найти все нулевые элементы и заменить их вместе с соседними элементами на 3.
        import numpy as np
        import random

        n = int(input("Number n: "))
        f = [random.randint(0, 9) for i in range(0, n)]

        b = []

        print(f)

        i = 0

        while i<len(f):
            if i == 0:
                if f[i] == 0:
                    f[i] = 0
                    f[i+1] = 0
                    i+=2
                else:
                    i+=1
            elif i == len(f)-1:
                if f[i] == 0:
                    f[i-1] = 0
                    f[i] = 0
                    i+=2
                else:
                    break
            else:
                if f[i] == 0:
                    f[i-1] = 0
                    f[i] = 0
                    f[i+1] = 0
                    i+=2
                else:
                    i+=1

        print(f)
        
68. Преобразовать массив таким образом, чтобы сначала располагались все элементы, модуль которых не превышает единицу, а потом – все остальные.
        import numpy as np ##Можно считать за решение, но можно было обойтись и без двух новых списков, я пытался, не хватает icq
        import random

        n = int(input("Number n: "))
        f = [random.randint(-9, 9) for i in range(0, n)]
        print(f)

        g = 0

        r = []
        l = []

        for i, j in enumerate(f):
            if abs(j)<=1:
                r.append(j)
            else:
                l.append(j)

        f = r+l       

        print(f)
        
69. Даны два массива. Сформировать третий массив, состоящий из тех элементов, которые: а) присутствуют в обоих массивах; б) присутствуют только в одном из массивов.
        import numpy as np
        import random

        per = [random.randint(0, 99) for i in range(5)]
        sec = [random.randint(0, 99) for i in range(5)]

        a = list(set(per) & set(sec))
        b = list(set(per) ^ set(sec))

        print(per)
        print(sec)
        print(a)
        print(b)
        
70. Дан массив. Осуществите циклический сдвиг массив на k единиц вправо, если первый наименьший элемент массива расположен раньше последнего наибольшего элемента массива, и влево, если иначе.
        import random

        def shift(lst, steps):
            if steps < 0:
                steps = abs(steps)
                for i in range(steps):
                    lst.append(lst.pop(0))
            else:
                for i in range(steps):
                    lst.insert(0, lst.pop())

        nums = [random.randint(0, 10) for i in range(10)]
        print(nums)

        if nums.index(max(nums))>nums.index(min(nums)):
            k = int(input("Number k: "))
            shift(nums, k)
            print(nums)
        else:
            k = int(input("Number k: "))
            print(shift(nums, k))
            
71. Даны два массива. Определите, существуют ли в первом массиве такие два элемента, что их сумма равна сумме каких-либо трех элементов второго массива.
        per = [1, 2, 6] ##Подбор всех комбинаций епта, если работать с большими числами, может не хватить оперативки, этож List!
        sec = [1, 3, 4]

        gg = []
        wp = []
        res = []

        for i in per:
            for j in per:
                if [i, j] not in gg:
                    gg.append([i, j])
                else:
                    pass

        for i in sec:
            for j in sec:
                for k in sec:
                    if [i, j, k] not in wp:
                        wp.append([i, j, k])
                    else:
                        pass
        for i in gg:
            for j in wp:
                if sum(i) == sum(j):
                    res.append([i, j])
                else:
                    pass

        print(gg, '\n')
        print(wp, '\n')
        print(res)

72. Дана упорядоченная последовательность an чисел от 1 до N. Из копии данной последовательности bn удалили одно число, а оставшиеся перемешали. Найти удаленное число.
        import random

        n = int(input("Number n: "))
        massive = [i for i in range(1, n)]
        print(massive)

        b = int(input("Number b: "))-1
        del massive[b]
        print(massive)

        qq = sorted(massive, key=lambda element: random.random())

        for i in range(1, n):
            if i not in qq:
                print("Спрятанное число:", i)
                break
            else:
                pass
                
73. Дан массив, в котором количество отрицательных элементов равно количеству положительным. Поменяйте местами первый отрицательный и первый положительный, второй отрицательный и второй положительный и так далее.
        import random

        massive = [-1, 2, 5, -7, 1, 1, -5, -9]

        plus_massive = []
        minus_massive = []

        p = 0
        m = 0

        print(massive)

        for i, j in enumerate(massive):
            if j>=0:
                plus_massive.append(j)
            else:
                minus_massive.append(j)

        for i, j in enumerate(massive):
            if j>=0:
                massive[i] = minus_massive[m]
                m+=1
            else:
                massive[i] = plus_massive[p]
                p+=1

        print(massive)
        print(plus_massive)
        print(minus_massive)

74. Удалите в целочисленном массиве все положительные числа, которые являются палиндромами.
        import random

        massive = [-1, 2, 5, -7, 1, 1001, -5, -9, 101, 8857, 222, 11]

        i = 0

        print(massive)

        while i<len(massive):
            if massive[i]>0:
                slicew = list(str(massive[i]))
                if len(slicew)>=2:
                    if slicew[::-1] == slicew:
                        del massive[i]
                        i=i
                    else:
                        i+=1
                else:
                    i+=1
            else:
                i+=1

        print(massive)
        ###
        import random ##Прикольно
        massive = [-1, 2, 5, -7, 1, 1001, -5, -9, 101, 8857, 222, 11]
        counter = 0
        for i in massive:
            if i>0:
                slicew = list(str(i))
                if len(slicew)>=2:
                    if slicew[::-1] == slicew:
                        print("Palindrome:", i)
                        counter+=1
                    else:
                        pass
                else:
                    pass
            else:
                pass
        if counter == 0:
            print("Massive have not numbers which more than 0 and have palindorme properety")
        else:
            print("Quantity such numbers:", counter)

75. Дан массив. Сформировать новый массив, в котором идут сначала отрицательные элементы, затем нули, затем положительные.
        import random

        massive = [-1, 2, 5, -7, 1, 1001, -5, -9, 101, 8857, 222, 11, 0, 0, 1, 0]

        minus_num = []
        zeros = []
        plus_num = []

        print(massive)

        for i in massive:
            if i<0:
                minus_num.append(i)
            elif i==0:
                zeros.append(i)
            else:
                plus_num.append(i)

        massive = minus_num + zeros + plus_num

        print(massive)
        
76. Даны два массива. Определите все серии подряд идущих элементов из первого массива (серия может состоять и из одного элемента), каждая из которых совпадает с какой-нибудь серией подряд идущих элементов второго массива.
        import random

        massive1 = [-1, 2, 5, -7, 1, 5, 5, 6]
        massive2 = [0, 0, 4, 3, 1, 4, 5, 6, 9, 6]

        print(massive1)
        print(massive2)

        def ss(minm, maxm):
            i = 0
            coincidence = []

            while i<len(minm):
                if minm[i] == maxm[i]:
                    coincidence.append(i+1)
                    i+=1
                else:
                    i+=1

            return coincidence

        if len(massive1)>=len(massive2):
            print("Элементы совпали на вот этих индексах:",ss(massive2, massive1))
        else:
            print("Элементы совпали на вот этих индексах:", ss(massive1, massive2))

77. Дан массив из n элементов. Переставьте его элементы случайным образом.
        import random

        massive = [-1, 2, 5, -7, 1, 5, 5, 6]

        print(sorted(massive, key=lambda element: random.random()))
        
78. В данном массиве каждый элемент равен 0, 1  или 2. Переставить элементы массива так, чтобы сначала располагались все нули, затем все единицы и, наконец, все двойки. Дополнительный массив не использовать.
        import random

        massive = sorted([random.randint(0, 2) for i in range(10)], key=lambda element: random.random())

        print(massive)
        print(sorted(massive))
        
79. Даны два упорядоченных по возрастанию массива. Образовать из этих двух массивов единый упорядоченный по возрастанию массив.
        import random

        massive1 = [i for i in range(0, 20)]
        massive2 = [i for i in range(4, 25)]

        print(sorted(massive1+massive2))
        
80. Осуществить поиск данного числа в упорядоченном по возрастанию массиве методом бинарного поиска.
        import random ##Просто великолепно!

        massive = [random.randint(0, 99) for i in range(0, 10)]
        massive.sort()
        print(massive, len(massive))

        value = int(input("Number value: "))

        mid = len(massive)//2
        left = 0
        right = len(massive)-1

        while massive[mid] != value and left <= right:
            if value > massive[mid]:
                left = mid + 1
            else:
                right = mid - 1
            mid = (left + right)//2

        if left>right:
            print("No value")
        else:
            print("ID =", mid)
            
81. Дан массив натуральных чисел. Найти наименьшее натуральное число, не представимое суммой никаких элементов массива. Сумма может состоять и из одного слагаемого, но каждый элемент массива может входить в нее только один раз.
        import random ##Ебаный день потратил, и все еще не понял как работает этот код, магическая математика

        def findSmallest(arr, n): 
            res = 1

            for i in range(0, n): 
                if arr[i] <= res: 
                    res = res + arr[i] 
                else: 
                    break

            return res

        massive = sorted([1, 2, 5, 10, 20, 40])

        print(massive)
        print(findSmallest(massive, len(massive)))

82. В данном массиве найти серию подряд идущих элементов наибольшей длины, в которой первое число равно последнему, второе - предпоследнему и так далее.

